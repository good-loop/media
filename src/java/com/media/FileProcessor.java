package com.media;

import java.io.File;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import org.apache.commons.io.FilenameUtils;

import com.media.data.MediaObject;
import com.winterwell.utils.Proc;
import com.winterwell.utils.Utils;
import com.winterwell.utils.containers.ArrayMap;
import com.winterwell.utils.io.FileUtils;
import com.winterwell.utils.log.Log;

/**
 * See {@link MediaCacheServlet} for info on the directory structure this uses
 * and the non-Java dependencies e.g. imagemagick.
 * 
 * Depends on apt packages:
 * - fontforge: conversion of fonts
 * - fonttools: subsetting of fonts with "pyftsubset"
 * - brotli: enable fontforge to use proper WOFF2 compression
 * (sudo apt install fontforge fonttools brotli)
 * 
 * TODO @Roscoe - Could you add a unit test for this? Thanks.
 * 
 * @author Roscoe
 *
 */
public class FileProcessor {
	// TODO: Would it be worth selecting quality reduction based on some maximum size?
	// i.e always want mobile images below 300kB, so reduce image to get as close as possible without creating a grainy mess
	public static final String STANDARD_RES_QUALITY = "70";
	public static final String LOW_RES_QUALITY = "50";
	// Images already below 50kB do not require further processing
	public static final long MINIMUM_IMAGE_SIZE = 50000;
	// File types supported by jpegoptim
	public static final List<String> JPEGOPTIM_SUPPORTED_TYPES = Arrays.asList("jpg", "jpeg");
	public static final List<String> PROCESSABLE_IMAGE_TYPES = Arrays.asList("jpg", "jpeg", "png");
	protected static final String LOGTAG = null;
	
	public File rawDest;
	public File standardDest;
	public File mobileDest;
	// Custom destinations to allow overriding default raw/standard/mobile
	public Map<String, File> dests;
	
	protected File uploadsDir;

	public final List<String> commands;
	
	protected FileProcessor(File uploadsDir, File rawDest, File standardDest, File mobileDest, List<String> commands) {
		this.uploadsDir = uploadsDir;
		this.rawDest = rawDest;
		// Moderately compressed version. Generated by either doProcessImage or doProcessVideo
		this.standardDest = standardDest;
		// Most compressed version. Generated by either doProcessImage or doProcessVideo
		this.mobileDest = mobileDest;
		
		this.commands = commands;
	}
	
	/**
	 * Store the file in a new DBAsset
	 * @param tempFile
	 * @param name
	 * @param params url parameters
	 * @return
	 */
	public static Map<String, MediaObject> process(ExecutorService pool, File uploadsDir, File rawDest, File standardDir, File mobileDir, Map params) throws FileProcessException
	{
		// Moderately compressed version. Generated by either doProcessImage or doProcessVideo
		if (standardDir == null) standardDir = FileUtils.getDirectory(uploadsDir, "standard");
		// Most compressed version. Generated by either doProcessImage or doProcessVideo
		if (mobileDir == null) mobileDir = FileUtils.getDirectory(uploadsDir, "mobile");
		
		File standardDest = getDestFile(standardDir, rawDest);
		File mobileDest = getDestFile(mobileDir, rawDest);
		
		// Map of absolute paths
		Map<String, MediaObject> _assetArr;
		
		try {
			// Always make this check first
			if (Files.isSymbolicLink(rawDest.toPath())) throw new FileProcessException("No symbolic links allowed!");
			if (rawDest.getName().equals("") || rawDest.getName() == null) {
				Log.w("Empty filename??", rawDest);
				return new ArrayMap<>(); // no-op
			}
			if (FileUtils.isImage(rawDest)) {
				FileProcessor imageProcessor = FileProcessor.imageProcessor(uploadsDir, rawDest, standardDest, mobileDest);
				_assetArr = imageProcessor.run(pool, params);
			} else if (FileUtils.isVideo(rawDest)) {
				FileProcessor videoProcessor = FileProcessor.videoProcessor(uploadsDir, rawDest, standardDest, mobileDest, params);
				_assetArr = videoProcessor.run(pool, params);
			} else if (FileUtils.isFont(rawDest)) {
				// Fonts go in /uploads/fonts/FONT_NAME/
				// Original renamed to "raw.ttf" (or "raw.otf" etc)
				String fontDirName = "fonts/" + FileUtils.getBasename(rawDest);
				String rawFontExtension = FileUtils.getType(rawDest);
				File baseFontDest = FileUtils.getDirectory(uploadsDir, fontDirName);
				File rawFontDest = getDestFile(baseFontDest, new File("raw." + rawFontExtension));
				FileUtils.move(rawDest, rawFontDest);
				// Subsetted versions in same dir named EN.woff, EN.woff2, DE.woff, DE.woff2 etc
				FileProcessor fontProcessor = FileProcessor.fontProcessor(uploadsDir, rawFontDest, baseFontDest);
				_assetArr = fontProcessor.run(pool, params);
			} else if (FileUtils.isDocument(rawDest)) {
				// Documents are currently not processed in any way.
				_assetArr = Map.of("raw", new MediaObject(rawDest));
			} else if (FileUtils.isWebDoc(rawDest)) {
				// Not processed
				_assetArr = Map.of("raw", new MediaObject(rawDest));
			} else if (FileUtils.isArchive(rawDest)) {
				File extParentDir = FileUtils.getDirectory(uploadsDir, "raw");
				if (!extParentDir.exists()) extParentDir.mkdirs();
				File extractDir = FileUtils.getDirectory(new File(uploadsDir, "raw"), FilenameUtils.removeExtension(rawDest.getName()) + "-extract");
				FileProcessor archiveProcessor = RecursiveFileProcessor.archiveProcessor(uploadsDir, rawDest, standardDir, mobileDir, extractDir, params);
				_assetArr = archiveProcessor.run(pool, params);
			} else {
				Log.w("Unrecognized filetype: " + FileUtils.getType(rawDest) + ", treat with caution!");
				_assetArr = Map.of("raw", new MediaObject(rawDest));
			}
		} catch (Throwable e) {
			FileUtils.delete(rawDest);
			FileUtils.delete(standardDest);
			FileUtils.delete(mobileDest);
			throw new FileProcessException("Failed to process file " + rawDest.getName(), e);
		}
		
		return _assetArr;
	}
	
	/**
	 * Does NOT move the tempFile
	 * @param user
	 * @param tempFile
	 * @return suggested dest file
	 * TODO implement normalizing somewhere
	 */
	public static File getDestFile(File dir, File tempFile) {
		// Minor hack: Normalise M4V to MP4, to conform to the VAST spec for video formats
		String destName = tempFile.getName().replaceAll("\\.m4v$", ".mp4");
		File dest = FileUtils.getNewFile(new File(dir, destName));
		return dest;
	}

	/** Assumes that there will already be an image in /uploads/raw for it to find **/
	public static FileProcessor imageProcessor(File uploadsDir, File rawDest, File standardDest, File mobileDest) {
		String inputImagePath = rawDest.getAbsolutePath();
		String standardImagePath = standardDest.getAbsolutePath();
		String lowResImagePath = mobileDest.getAbsolutePath();
		
		String fileType = FileUtils.getType(rawDest.getName());
		
		String command = "";
		
		// Only process JPG, JPEG, PNG - other types just copy into /standard and /mobile		
		if(!PROCESSABLE_IMAGE_TYPES.contains(fileType) || rawDest.length() < MINIMUM_IMAGE_SIZE) {
			Log.d("Image file is below 50kB. No processing will be done, but the raw image will be copied to the standard, mobile and raw directories");
			// TODO Symlink instead of copying, like MediaCacheServlet
			command = "cp " + inputImagePath + " " + standardImagePath
					+ "; " + "cp " + inputImagePath + " " + lowResImagePath;
		} else {
			if (JPEGOPTIM_SUPPORTED_TYPES.contains(fileType)) {
				command = "/usr/bin/convert " + inputImagePath + " -quality " + STANDARD_RES_QUALITY + " " + standardImagePath
						+ (JPEGOPTIM_SUPPORTED_TYPES.contains(fileType) ? "&& /usr/bin/jpegoptim " + standardImagePath : "")
						+ "; " + "/usr/bin/convert " + inputImagePath + " -quality " + LOW_RES_QUALITY + " " + lowResImagePath
						+ (JPEGOPTIM_SUPPORTED_TYPES.contains(fileType) ? "&& /usr/bin/jpegoptim " + lowResImagePath : "");
			} else {
				// optipng will iterate through different png compression methods and keep the result with smallest file size
				command = "cp " + inputImagePath + " " + standardImagePath + "; "
						// Change image mode to indexed (lossy but preserves alpha)
						+ "/usr/local/bin/pngquant -s1 --strip --verbose --skip-if-larger --force --ext .png " + standardImagePath + "; "
						// Optimise compression as much as possible
						+ "/usr/bin/zopflipng -y -m" + standardImagePath + " " + standardImagePath + "; "
						// Copy result to mobile directory
						+ "cp " + standardImagePath + " " + lowResImagePath;
			}
		}
		
		List<String> commands = Arrays.asList("/bin/bash", "-c", command);
		
		return new FileProcessor(uploadsDir, rawDest, standardDest, mobileDest, commands);
	}


	public static FileProcessor videoProcessor(File uploadsDir, File rawDest, File standardDest, File mobileDest, Map params) {
		String inputVideoPath = rawDest.getAbsolutePath();
		String lowResVideoPath = mobileDest.getAbsolutePath();
		String highResVideoPath = standardDest.getAbsolutePath();
		
//		List<Object> cropFactors = Arrays.asList(
//				params.get("crop-top"),
//				params.get("crop-bottom"),
//				params.get("crop-left"),
//				params.get("crop-right")
//		);
//		
//		// Add cropping parameters if these have been specified
//		String cropCommand = ( cropFactors.stream().anyMatch(v -> v != null) ) 
//							? " --crop " + cropFactors.stream().reduce( "", (out, s) -> out + (s != null ? (String) s : "0") + ":")
//							: "";
		// Cropping is now explicitly OFF. 2021-06-17 DA
		// Switching from HandBrake-CLI to ffmpeg -- HandBrake-CLI no longer is up-to-date on ubuntu 18.04
		// Changing scale from e.g. 1280:720 to 720:720:force_original_aspect_ratio=increase:force_divisible_by=2
		// Meaning - start by assuming we'll scale to a 720x720 box, but increase whichever dimension is necessary
		// to maintain original aspect ratio, and round resultant size to a multiple of 2 to satisfy the encoder.
		// This allows the same command to handle 4:3, 16:9, portrait, and various non-standard aspect ratios. --RM August 2021
		// Removing "setsar=1:1" clause from -vf param list: it was breaking anamorphic videos by discarding pixel-aspect info. --RM July 2023
		String command = "taskset -c 0,1,2,3 ffmpeg -y -i " + inputVideoPath + " -ac 2 -c:a aac -b:a 96k -c:v libx264 -b:v 500k -maxrate 500k -bufsize 1000k -pix_fmt yuv420p -vf colorspace=bt709:iall=bt601-6-625:fast=1,scale=480:480:force_original_aspect_ratio=increase:force_divisible_by=2,deblock=filter=strong:block=4 -level:v 3.1 " + lowResVideoPath
				+ "; taskset -c 0,1,2,3 ffmpeg -y -i " + inputVideoPath + " -ac 2 -c:a aac -b:a 96k -c:v libx264 -b:v 750k -maxrate 750k -bufsize 1500k -pix_fmt yuv420p -vf colorspace=bt709:iall=bt601-6-625:fast=1,scale=720:720:force_original_aspect_ratio=increase:force_divisible_by=2,deblock=filter=strong:block=4 -level:v 3.1 " + highResVideoPath;
		List<String> commands = Arrays.asList("/bin/bash", "-c", command);
		
		return new FileProcessor(uploadsDir, rawDest, standardDest, mobileDest, commands);
	}
	
	/** List of files containing character subsets for languages / language groups in /media/src/resources/orthographies/ */
	static List<String> orthographies = Arrays.asList("DE", "EN", "ES", "FR", "IT", "PT", "ARABIC", "CYRILLIC", "EASTERN_EUROPE", "NORDIC", "numerals");

	static String subsetCmdBase = "pyftsubset $INPUT --unicodes-file=/home/winterwell/media/src/resources/orthographies/$SUBSET.txt --output-file=$OUTPUT;";
	static String convertCmdBase = "fontforge -lang=ff -c 'Open(\"$INPUT\"); Generate(\"$OUTPUT\")';";


	/**
	 * Run an uploaded font through Python fontTools pyftsubset and FontForge conversion
	 * to generate a set of much smaller, language-specific, web-ready font files.
	 * @param rawFont Original font in TTF, OTF, WOFF, WOFF2
	 * @param fontDir Directory to output all generated fonts
	 * @return
	 */
	public static FileProcessor fontProcessor(File uploadsDir, File rawFont, File fontDir) {
		String inputFontPath = rawFont.getAbsolutePath();

		Map<String,File> dests = new HashMap<String, File>();

		List<String> commands = new ArrayList();
		commands.add("/bin/bash");
		commands.add("-c");
		String processSubsetsCommand = "";

		// Generate a non-subsetted, but converted, version of the font
		File completeWoffDest = new File(fontDir, "all.woff");
		File completeWoff2Dest = new File(fontDir, "all.woff2");
		String completeConvertCmd = convertCmdBase.replace("$INPUT", rawFont.getAbsolutePath());
		processSubsetsCommand += completeConvertCmd.replace("$OUTPUT", completeWoffDest.getAbsolutePath());
		processSubsetsCommand += completeConvertCmd.replace("$OUTPUT", completeWoff2Dest.getAbsolutePath());
		dests.put("all-woff", completeWoffDest);
		dests.put("all-woff2", completeWoff2Dest);

		// Generate all subsets right now in case we need them later
		for (String subset : orthographies) {
			// Subset raw.otf to eg EN.otf, then convert to EN.woff and EN.woff2
			File subsetDest = new File(fontDir, subset + "-base-subset." + FileUtils.getType(rawFont));
			File woffDest = new File(fontDir, subset + ".woff");
			File woff2Dest = new File(fontDir, subset + ".woff2");

			// Construct the pyftsubset command with input, output and subset
			String subsetCmd = subsetCmdBase.replace("$INPUT", inputFontPath);
			subsetCmd = subsetCmd.replace("$SUBSET", subset);
			subsetCmd = subsetCmd.replace("$OUTPUT", subsetDest.getAbsolutePath());

			// Construct the fontforge command with input = output of subset command
			String convertCmd = convertCmdBase.replace("$INPUT", subsetDest.getAbsolutePath());

			// Subset, convert to WOFF, convert to WOFF2, delete the unconverted subset.
			processSubsetsCommand += (
					subsetCmd
					+ convertCmd.replace("$OUTPUT", woffDest.getAbsolutePath())
					+ convertCmd.replace("$OUTPUT", woff2Dest.getAbsolutePath())
					+ "rm " + subsetDest.getAbsolutePath() + ";"
			);
			// Add destination files to output set
			dests.put(subset + "-woff", woffDest);
			dests.put(subset + "-woff2", woff2Dest);
		}
		// Convert uploaded font to WOFF and WOFF2
		commands.add(processSubsetsCommand);

		FileProcessor fp = new FileProcessor(uploadsDir, rawFont, fontDir, null, commands);
		fp.dests = dests; // Set custom destination list
		return fp;
	}
	
	/**
	 * Unzip an archive - nothing fancy
	 * @param rawFile
	 * @param destDir
	 * @return
	 */
	public static RecursiveFileProcessor archiveProcessor (File uploadsDir, File rawFile, File standardDir, File mobileDir, File destDir, Map params) throws ZipScanException {
		String inputArchivePath = rawFile.getAbsolutePath();
		String destPath = destDir.getAbsolutePath();
		
		// Setup unzipping process
		List<String> commands = new ArrayList<String>();
		commands.add("/bin/bash");
		commands.add("-c");
		commands.add("unzip " + inputArchivePath + " -d " + destPath);
		
		String mainFile = (String) params.get("main_file");
		
		// Check zip file contents is ok before continuing
		try (ZipFile zipFile = new ZipFile(inputArchivePath)) {
			boolean foundMainFile = mainFile == null; // If we have no mainFile parameter, just set true
			Enumeration<? extends ZipEntry> entries = zipFile.entries();
		    while (entries.hasMoreElements()) {
		        ZipEntry entry = entries.nextElement();
		        // Check entry is valid
		        if (!entry.isDirectory() && !isSafeProcessableType(entry.getName())) {
		        	throw new ZipScanException("Zip contained unsafe contents! Offending file: " + entry.getName());
		        }
		        if (entry.getName().equals(mainFile)) foundMainFile = true;
		    }
		    if (!foundMainFile) throw new ZipScanException("Could not find required file in zip: " + mainFile);
		} catch (Throwable e) {
			throw new ZipScanException("Archive scan failed", e);
		}
		
		Map<String, File> dests = new ArrayMap<>();
		dests.put("extract", destDir);
		RecursiveFileProcessor zfp = new RecursiveFileProcessor(uploadsDir, rawFile, standardDir, mobileDir, destDir, commands);
		zfp.dests = dests;
		return zfp;
	}
	
	public static boolean isSafeProcessableType (String filename) {
		boolean validType = FileUtils.isVideo(filename) ||
				FileUtils.isImage(filename) ||
				FileUtils.isArchive(filename) ||
				FileUtils.isDocument(filename) ||
				FileUtils.isFont(filename) ||
				FileUtils.isWebDoc(filename);
		return validType && FileUtils.isSafe(filename);
	}


	/** Perform the given conversion operation 
	 *  Need to provide pool of threads to run from **/
	public Map<String, MediaObject> run(ExecutorService pool, Map params) throws FileProcessException {
		pool.submit(() -> {
			Proc process = new Proc(this.commands);
			try {
				Log.d(LOGTAG, "run "+process);
				process.start();
				process.waitFor();
				Log.d(process.getOutput());
				if ( ! Utils.isBlank(process.getError())) {
					if (process.getError().contains("SEAC-like endchar operator is deprecated")) {
						// this is an ignorable warning about a font accent character
						Log.d(LOGTAG, "(ignore warning) process: "+process+" >>> "+process.getError());
					}
					Log.e(LOGTAG, "process: "+process+" >>> "+process.getError());
				}
			} catch (Throwable e) {
				Log.e(e);
				FileUtils.delete(rawDest);
				// Default or custom output files?
				if (this.dests == null) {
					FileUtils.delete(standardDest);
					FileUtils.delete(mobileDest);
				} else {
					for (Map.Entry<String, File> destEntry : dests.entrySet()) {
						FileUtils.delete(destEntry.getValue());
					}
				}
			} finally {
				FileUtils.close(process);
			}
		});
		
		Map out = new ArrayMap();
		
		out.put("raw", new MediaObject(this.rawDest));
		// Default or custom output files?
		if (this.dests == null) {
			out.put("standard", new MediaObject(this.standardDest));
			if (this.mobileDest != null) out.put("mobile", new MediaObject(this.mobileDest));
		} else {
			for (Map.Entry<String, File> destEntry : dests.entrySet()) {
				out.put(destEntry.getKey(), new MediaObject(destEntry.getValue()));
			}
		}

		return out;
	}
}

class FileProcessException extends Exception {
	public FileProcessException (String message, Throwable e) {
		super(message, e);
	}
	public FileProcessException (String message) {
		super(message);
	}
}

// Had to define outside class or unable to throw in static context
class ZipScanException extends Exception {
	public ZipScanException (String message) {
		super(message);
	}
	public ZipScanException (String message, Throwable e) {
		super(message, e);
	}
}
